import numpy as np
import cv2

#Changing colors to match green led ringlight
#Adding all the trackbars
#tracks yellow cube, put bounding box and display center
#doesn't start unless detecting cube
#press q to close video window


#setting up size of display 
cv2.namedWindow("frame", cv2.WINDOW_NORMAL)
cv2.resizeWindow("frame", 100,100)
cv2.namedWindow("detect", cv2.WINDOW_NORMAL)
cv2.resizeWindow("detect", 100,100)

kernel = np.ones((31,31), np.uint8)

#Captures Video
cap = cv2.VideoCapture(0)

#Creates Window named HSVBars
cv2.namedWindow('HSVBars')

#Strings because I'm lazy

wnd = 'HSVBars'
hl = 'Hue Low'
hh = 'Hue High'
sl = 'Saturation Low'
sh = 'Saturation High'
vl = 'Value Low'
vh = 'Value High'

#Trackbars for all variables

cv2.createTrackbar(hl, wnd, 0, 179, lambda:none)
cv2.createTrackbar(hh, wnd, 0, 179, lambda:none)
cv2.createTrackbar(sl, wnd, 0, 255, lambda:none)
cv2.createTrackbar(sh, wnd, 0, 255, lambda:none)
cv2.createTrackbar(vl, wnd, 0, 255, lambda:none)
cv2.createTrackbar(vh, wnd, 0, 255, lambda:none)

while(True):
	#reading every frame
	ret, img = cap.read()

	#increased upper HSV vals	
	if cv2.waitKey(1) & 0xFF == ord('q'):
        	break

	    # Convert the image from RGB to HSV color space.  This is required for the next operation.
	hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)

	    # The morphological 'open' operation is described here:
	    # https://docs.opencv.org/trunk/d9/d61/tutorial_py_morphological_ops.html
	    # It helps remove noise and jagged edges, note how the stray speckles are removed!
	   
	    # Blurring operation helps forthcoming findContours operation work better
	    # The values here can be adjusted to tune the detection quality.  (3,3) is a decent starting point

	#Read trackbar changes
	thl = cv2.getTrackbarPos(hl, wnd)
	thh = cv2.getTrackbarPos(hh, wnd)
	tsl = cv2.getTrackbarPos(sl, wnd)
	tsh = cv2.getTrackbarPos(sh, wnd)
	tvl = cv2.getTrackbarPos(vl, wnd)
	tvh = cv2.getTrackbarPos(vh, wnd)

	#Array for final values
	HSVLOW = np.array([thl, tsl, tvl])
	HSVHIGH = np.array([thh, tsh, tvh])

#Creates mask for range
mask = cv2.inRange(hsv, HSVLOW, HSVHIGH)

res = cv2.bitwise_and(frame, frame, mask = mask)

opened = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

blur = cv2.blur(opened, (1,1))
   
# Find contours
(_, cnts, _) = cv2.findContours(blur.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    

# Sometimes the contours operation will find more than one contour
	    # But if we did all our preliminary operations properly, then the contour we need will be
	    # the *largest* contour in the set of all contours.  The sorted operation below sorts
	    # the cnts array of contours by area, so the first contour should be the largest
	  
contours = sorted(cnts, key = cv2.contourArea, reverse = True)

	    # If no contours are detected, then don't try to process them or you'll get an error:
if len(contours) > 0	cnt1 = contours[0]
		
		# Draw a minimum area rectangle around the contour
rect1 = np.int32(cv2.boxPoints(cv2.minAreaRect(cnt1)))
		
		# Draw the contour over image
cv2.drawContours(blur, [rect1], -1, (255, 0, 0), 2)
M1 = cv2.moments(cnt1)
cx1 = int(M1['m10']/M1['m00'])
cy1 = int(M1['m01']/M1['m00'])
#draw center of cube on image
cv2.circle(blur,(cx1,cy1), 50, (0,100,100))
cv2.imshow('detect', blur)
blur = cv2.blur(opened, (1,1))
	    
# When everything done, release the capture
cv2.imshow('frame', img, wnd, res)

cap.release()
cv2.destroyAllWindows()
